= 前提知識

:leveloffset: +1

include::sections/three-tier-architecture.adoc[]
include::sections/layered-architecture.adoc[]

:leveloffset: -1



== ドメイン駆動設計

https://www.domainlanguage.com/ddd/reference/[DDD Reference]

Layered Architecture
Entities
Value Objects
Domain Events
Services
Modules
Aggregates
Repositories
Factories




アプリケーション



アプリケーションの具体化

オニオンアーキテクチャ

クリーンアーキテクチャ



ドメイン駆動設計（ DDD ）との関係

ドメインとは






依存方向
依存関係の逆転
自分と同じレイヤーとさらに内側しか知らない。
知らないものが変更されても何も影響は受けずに済む。
セカンダリ側だと処理の流れと依存関係が逆になるが、そこはインターフェースを介して実装に処理を
渡すことで解消できる

セカンダリだとポートがインターフェース、アダプタが実装となっている。
プライマリポートだと依存関係の逆転は起きずドメイン内の処理を起動する必要があるので、インターフェースにはする必要はないが、
役割の分担としてポートはインターフェース、その実装がポートと同じ層のユースケース（クリーンアーキテクチャで
ユースケースインタラクタと呼んでいるものに相当）とする。


プライマリ側とセカンダリ側は依存関係上は並列


実装順

アダプタやポートはテスト用から



=== ドメインレイヤー

実現したい概念そのもの

エンティティ
ライフサイクルと ID を持つ
変化するパラメータを持ったオブジェクト。持っているパラメータが変化しても存在は同じ。
存在を見分けるために不変の id を持つ。
オブジェクトが満たすべきルールも含む
可能な限り値オブジェクトを使った方がよい（複雑さを避ける）？

値オブジェクト
不変なオブジェクト。値が同じなら同じ存在
ライフサイクルはない
オブジェクトが満たすべきルールも含む
関数は副作用を持たない

属性が複数の場合もある

参考 : https://learn.microsoft.com/ja-jp/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/implement-value-objects

値オブジェクトなのか単なる属性なのかは意識して分けること
制約がゆるく特別な意味を持たせる必要のないものは値オブジェクトとしてモデリングは行わず、
UML のクラス図などでは単なるデータ型（言語に用意されているプリミティブ型や列挙型など）で定義された属性で十分。

サービス
物としてモデリングできない存在
値オブジェクトやエンティティを扱う。
手続きと混同しないように。値オブジェクトやエンティティ単体ではできないような操作のために使う？


ドメインイベント

コンテキスト境界
同じものでも適用範囲の境界をはっきりさせれば複数モデルが存在しても良い
実装時にはコンテキストでアプリケーション自体を分けた方が分かりやすい
参考 : https://little-hands.hatenablog.com/entry/2017/12/07/bouded-context-implementation

コンテキストマッピング


関連
オブジェクト同士の関係性パターン

集約
関連するオブジェクトの集合
カプセル化
変更単位であり一貫性を保障
ルートとなるエンティティが存在（値オブジェクトだけの集合は UML でいうところのコンポジションに相当？）
ライフサイクルのパターンの 1 種とも言えるが、メインは関連性の話


ライフサイクル
エンティティに対するライフサイクルパターン
値オブジェクトは値そのものに意味があり常時存在するが、エンティティは ID を与えられた時点で生み出される。

ファクトリ
集約の作成が複雑な場合などに利用

リポジトリ
集約の置き場所
集約に対する CRUD








=== ユースケース（アプリケーション）レイヤー

アプリケーションで実現するためのルール


