= 前提知識

== 3 （ n ）層（ Tier ）アーキテクチャと 3 （ n ）レイヤー（ Layer ）アーキテクチャ

.層（ Tier ）とレイヤー（ Layer ）
[quote, IBM, 'https://www.ibm.com/jp-ja/topics/three-tier-architecture[3層アーキテクチャーとは]']
____
層とレイヤーは同じではありません。 「レイヤー」とは、ソフトウェアの機能部を指しますが、
「層」とは、他の部分から分離してインフラストラクチャーで実行されるソフトウェアの機能部を指します。 
例えば、電話の連絡先アプリは、3レイヤー・アプリケーションですが、3つのレイヤーがすべてその電話上で機能するため、1層 のアプリケーションです。
____

以降では分かりやすくするためにレイヤーに関しては「層」という言葉は使わず「レイヤー」で表現する。

=== 3 （ n ）層（ Tier ）アーキテクチャ

古くから Web アプリケーションなどで使われている一般的な構造

物理的に分けることが可能な「層」

アプリケーション内での論理的な分割である 3 レイヤー（ Layer 、層）アーキテクチャや
ヘキサゴナルアーキテクチャの前提となっているレイヤードアーキテクチャと構造や用語が似ており混同を
避けるために紹介する。


参考）
* https://www.ibm.com/jp-ja/topics/three-tier-architecture[3層アーキテクチャーとは]
* https://docs.aws.amazon.com/whitepapers/latest/serverless-multi-tier-architectures-api-gateway-lambda/welcome.html[AWS Serverless Multi-Tier Architectures with Amazon API Gateway and AWS Lambda]
* https://learn.microsoft.com/ja-jp/windows/win32/cossdk/using-a-three-tier-architecture-model[3 層アーキテクチャ モデルの使用]


プレゼンテーション層、ユーザーサービス層::
  プレゼンテーション層とは、アプリケーションのユーザー・インターフェースかつアプリケーションの通信層であり、エンド・ユーザーはこの層でアプリケーションと対話します。 
  その主な目的は、ユーザーに情報を表示し、情報をユーザーから収集することです。 
  この第1層は、デスクトップ・アプリケーションであるWebブラウザー、またはグラフィカル・ユーザー・インターフェース（GUI）などで実行できます。
  Webプレゼンテーション層は通常、HTML、CSS 、JavaScriptを使用して開発されます。 デスクトップ・アプリケーションは、プラットフォームに応じてさまざまな言語で記述することができます。
アプリケーション層、論理層、中間層、ビジネスサービス層、ビジネスロジック層::
  アプリケーション層（論理層または中間層とも呼ばれます）は、アプリケーションの中核です。
  この層では、プレゼンテーション層で収集された情報が、特定のビジネス・ルールのセットであるビジネス・ロジックを使用して処理されます
  （データ層の他の情報に対して処理される場合もあります）。 アプリケーション層は、データ層内でデータの追加、削除、または変更を行うこともできます。 
データ層、データサービス層::
  データ層（データベース層、データ・アクセス層、またはバックエンドと呼ばれることもあります）は、アプリケーションによって処理された情報が保管され、管理される場所です。
  これは、PostgreSQL、MySQL、MariaDB、Oracle、Db2、Informix、Microsoft SQL Serverなどのリレーショナル・データベース管理システムである場合、またはCassandra、CouchDB、MongoDBなどの
  NoSQLデータベース・サーバー内にある場合があります。          

3層アプリケーションでは、すべての通信がアプリケーション層を経由します。 プレゼンテーション層とデータ層は、相互に直接通信できません。

=== Web アプリケーションの例

単純にクライアント層とサーバ層の 2 層とする考え方もあるが、ここでは n 層に分けた場合を考える。

1 層目::
  クライアントマシン。役割としてはプレゼンテーション層。マシン内は Web ブラウザなど。
2 層目::
  Web サーバマシン。役割としてはプレゼンテーション層。マシン内は Apache HTTP Server や Nginx など。
3 層目::
  アプリケーションサーバマシン。役割としてはアプリケーション層。マシン内は Apache Tomcat など。
4 層目::
  DB サーバマシン。役割としてはデータ層。マシン内は PostgreSQL など。

補足）

* クライアントマシンはサービスの外と見てこれを除いたサーバ側だけで 3 層と呼ばれるのが多そう。
* Web サーバマシンとアプリケーションサーバマシンを共通のものとして中間層とした場合もある。参考 : https://www.ibm.com/docs/ja/db2-for-zos/13?topic=environment-architectural-characteristics-web-based-applications[Web ベース・アプリケーションのアーキテクチャーの特性]


=== 3 （ n ）レイヤー（ Layer ）アーキテクチャ

物理層のうち、アプリケーション層の中の話




== レイヤードアーキテクチャ

ドメインの概念の登場



.レイヤードアーキテクチャにおけるレイヤー
[cols="1,1"options="noheader,autowidth",stripes=hover]
|===
^s|ユーザーインターフェースレイヤー
a|
ユーザの入出力

^s|インフラストラクチャレイヤー
a|
DB などのデータアクセス

^s|アプリケーションレイヤー
a|
アプリケーションロジック、ユースケース

^s|ドメインレイヤー
a|
ドメインモデル、ビジネスロジック
|===

依存関係は考え方によって前後（依存関係の逆転）するが、 DDD として重要なのはドメインレイヤーが他のレイヤーから
独立していること



== ドメイン駆動設計

https://www.domainlanguage.com/ddd/reference/[DDD Reference]

Layered Architecture
Entities
Value Objects
Domain Events
Services
Modules
Aggregates
Repositories
Factories




アプリケーション



アプリケーションの具体化

オニオンアーキテクチャ

クリーンアーキテクチャ



ドメイン駆動設計（ DDD ）との関係

ドメインとは






依存方向
依存関係の逆転
自分と同じレイヤーとさらに内側しか知らない。
知らないものが変更されても何も影響は受けずに済む。
セカンダリ側だと処理の流れと依存関係が逆になるが、そこはインターフェースを介して実装に処理を
渡すことで解消できる

セカンダリだとポートがインターフェース、アダプタが実装となっている。
プライマリポートだと依存関係の逆転は起きずドメイン内の処理を起動する必要があるので、インターフェースにはする必要はないが、
役割の分担としてポートはインターフェース、その実装がポートと同じ層のユースケース（クリーンアーキテクチャで
ユースケースインタラクタと呼んでいるものに相当）とする。


プライマリ側とセカンダリ側は依存関係上は並列


実装順

アダプタやポートはテスト用から



=== ドメインレイヤー

実現したい概念そのもの

エンティティ
ライフサイクルと ID を持つ
変化するパラメータを持ったオブジェクト。持っているパラメータが変化しても存在は同じ。
存在を見分けるために不変の id を持つ。
オブジェクトが満たすべきルールも含む
可能な限り値オブジェクトを使った方がよい（複雑さを避ける）？

値オブジェクト
不変なオブジェクト。値が同じなら同じ存在
ライフサイクルはない
オブジェクトが満たすべきルールも含む
関数は副作用を持たない


サービス
物としてモデリングできない存在
値オブジェクトやエンティティを扱う。
手続きと混同しないように。値オブジェクトやエンティティ単体ではできないような操作のために使う？


ドメインイベント

コンテキスト境界
同じものでも適用範囲の境界をはっきりさせれば複数モデルが存在しても良い
実装時にはコンテキストでアプリケーション自体を分けた方が分かりやすい
参考 : https://little-hands.hatenablog.com/entry/2017/12/07/bouded-context-implementation

コンテキストマッピング


関連
オブジェクト同士の関係性パターン

集約
関連するオブジェクトの集合
カプセル化
変更単位であり一貫性を保障
ルートとなるエンティティが存在


ライフサイクル
エンティティに対するライフサイクルパターン

ファクトリ
集約の作成が複雑な場合などに利用

リポジトリ
集約の置き場所
集約に対する CRUD








=== ユースケース（アプリケーション）レイヤー

アプリケーションで実現するためのルール


