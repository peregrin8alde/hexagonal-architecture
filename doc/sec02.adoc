= ヘキサゴナルアーキテクチャ

== レイヤー

.ヘキサゴナルアーキテクチャにおけるレイヤー
[cols="1,1,1"options="noheader,autowidth",stripes=hover]
|===
^a| *アクター*
a|プライマリアクター

アプリケーション（のアダプタ）を呼び出すもの。ドライバと呼ぶ場合も。

例）

* テストハーネス（＝＞テストハーネスアダプタ）
* ターミナル（＝＞ CUI アダプタ）
* ユーザー（＝＞ GUI アダプタ）
* Web ブラウザ（＝＞ HTTP アダプタ）
* 連携アプリケーション（＝＞ アプリケーションアダプタ）
a|セカンダリアクター

^a| *アダプタ*
a|プライマリアダプタ（ #ユーザーインターフェース層# ）

アクターの UI とアプリケーションの UI の違いを調整するもの。

例）

* テストハーネスアダプタ
* CUI アダプタ
* GUI アダプタ
* HTTP アダプタ
* アプリケーションアダプタ

a|セカンダリアダプタ（ #インフラストラクチャ層# ）

^a| *アプリケーション* （ #アプリケーション層# 、#ドメイン層# ）
2+a| 
* *プライマリポート*
* *セカンダリポート*
* その他
|===

なお、オニオンアーキテクチャやクリーンアーキテクチャではアプリケーション部分がさらにレイヤー分け／詳細化されているため、
実装のイメージがしやすい。

他のアーキテクチャから／への置き換えや実装のしやすさを考慮して、ここではアプリケーション層とドメイン層を分けて以下に読み換える。

.ヘキサゴナルアーキテクチャにおけるレイヤー（独自）
[cols="1,1,1"options="noheader,autowidth",stripes=hover]
|===
^a| *アクター*
|プライマリアクター
|セカンダリアクター

^a| *アダプタ*
a|
プライマリアダプタ

* #ユーザーインターフェース層#
* プライマリポートの呼び出し

a|
セカンダリアダプタ

* #インフラストラクチャ層#
* セカンダリポートの実装

.2+^a| *アプリケーション*

2+^a| #アプリケーション層#
[cols="1,1"]
!===
a!プライマリポート

* ユースケースに合わせたサービスの実装
* ユースケースに合わせたドメイン層のセカンダリポートの呼び出し

a!
セカンダリポート


!===

2+^a| #ドメイン層#
[cols="1,1"]
!===
a!プライマリポート

* サービスのインターフェース

a!セカンダリポート

* リポジトリのインターフェース

2+^!ドメインオブジェクト（値オブジェクト、エンティティ、集約ルートエンティティ）
!===
|===


ポートはドメイン層で概念としてプログラミング言語でいうところのインターフェース機能などを使って枠だけ用意
サービスはアプリケーション層でユースケースに合わせて実装、アダプタ層（ユーザーインターフェース層）でユースケースに合った実装を利用
リポジトリはアダプタ層（インフラストラクチャ層）で実装、アプリケーション層でユースケースに合った実装を利用

参考として、オニオンアーキテクチャとクリーンアーキテクチャの場合は以下のようになる。

オニオンアーキテクチャ
アプリケーションサービス層にプライマリポートのインターフェース
ドメインサービス層にセカンダリポートのインターフェース

クリーンアーキテクチャ
エンティティ（ DDD のエンティティとは別物？）だけがドメイン層。ポートのインターフェースはユースケース層




入力側や出力側という表現だけではイメージしやすいかもしれないが、
入力へのレスポンスや出力されたデータの参照などが分かりにくくなるため、
公式の例のようにユーザサイドやデータサイド、オニオンアーキテクチャなどの U/I やインフラストラクチャなどの表現の方が良さそう
クリーンアーキテクチャだとコントローラーが入力とプレゼンテーターが出力となってデバイスを通してインフラストラクチャにアクセス
しそうに見える

アダプタについてはプライマリ側をエントリーポイント、セカンダリ側をアダプタと呼んでる例もあり

参考 : https://docs.aws.amazon.com/ja_jp/prescriptive-guidance/latest/hexagonal-architectures/best-practices.html[AWS Prescriptive Guidance, Building hexagonal architectures on AWS, Best practices]

ポート アプリケーション境界の内外のやり取りに利用
ユースケース アプリケーション境界上の内側に存在
ユースケースをポート（アプリケーション境界そのもの）の一部とするか、ポートとは区切られた内側の層とするか？
＝＞ クリーンアーキテクチャだと、境界線そのものがユースケース層であり、入力／出力ポートとインターアクターが存在する。
よって、ポートの一部と見るのが自然っぽい。ただし、外側とやり取りするのは入出力ポートの役割

