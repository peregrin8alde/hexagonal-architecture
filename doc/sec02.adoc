= ヘキサゴナルアーキテクチャ

== レイヤー

.ヘキサゴナルアーキテクチャにおけるレイヤー
[cols="1,1,1"options="noheader,autowidth",stripes=hover]
|===
^a| *アクター*
|プライマリアクター
|セカンダリアクター

^a| *アダプタ*
a|プライマリアダプタ（ #ユーザーインターフェース層# ）
a|セカンダリアダプタ（ #インフラストラクチャ層# ）

^a| *アプリケーション* （ #アプリケーション層# 、#ドメイン層# ）
2+a| 
* プライマリポート
* セカンダリポート
* その他
|===

なお、オニオンアーキテクチャやクリーンアーキテクチャではアプリケーション部分がさらにレイヤー分け／詳細化されているため、
実装のイメージがしやすい。

他のアーキテクチャから／への置き換えや実装のしやすさを考慮して、ここではアプリケーション層とドメイン層を分けて以下に読み換える。

.ヘキサゴナルアーキテクチャにおけるレイヤー（独自）
[cols="1,1,1"options="noheader,autowidth",stripes=hover]
|===
^a| *アクター*
|プライマリアクター
|セカンダリアクター

^a| *アダプタ*
a|
プライマリアダプタ

* #ユーザーインターフェース層#
* プライマリポートの呼び出し？実装？

a|
セカンダリアダプタ

* #インフラストラクチャ層#
* リポジトリの実装

.2+^a| *アプリケーション*

2+^a| #アプリケーション層#
[cols="1,1"]
!===
a!プライマリポート

* ユースケースに合わせたサービスの実装？インターフェース？
* ユースケースに合わせたドメイン層のセカンダリポートの呼び出し

a!
セカンダリポート


!===

2+^a| #ドメイン層#
[cols="1,1"]
!===
a!プライマリポート

* サービスのインターフェース？

a!セカンダリポート

* リポジトリのインターフェース

2+^!ドメインモデル（値オブジェクト、エンティティ、集約など）
!===
|===


入力側や出力側という表現だけではイメージしやすいかもしれないが、
入力へのレスポンスや出力されたデータの参照などが分かりにくくなるため、
公式の例のようにユーザサイドやデータサイド、オニオンアーキテクチャなどの U/I やインフラストラクチャなどの表現の方が良さそう
クリーンアーキテクチャだとコントローラーが入力とプレゼンテーターが出力となってデバイスを通してインフラストラクチャにアクセス
しそうに見える

アダプタについてはプライマリ側をエントリーポイント、セカンダリ側をアダプタと呼んでる例もあり

参考 : https://docs.aws.amazon.com/ja_jp/prescriptive-guidance/latest/hexagonal-architectures/best-practices.html[AWS Prescriptive Guidance, Building hexagonal architectures on AWS, Best practices]

ポート アプリケーション境界の内外のやり取りに利用
ユースケース アプリケーション境界上の内側に存在
ユースケースをポート（アプリケーション境界そのもの）の一部とするか、ポートとは区切られた内側の層とするか？
＝＞ クリーンアーキテクチャだと、境界線そのものがユースケース層であり、入力／出力ポートとインターアクターが存在する。
よって、ポートの一部と見るのが自然っぽい。ただし、外側とやり取りするのは入出力ポートの役割

