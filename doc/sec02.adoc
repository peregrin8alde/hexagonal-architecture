= ヘキサゴナルアーキテクチャ

== レイヤー

.ヘキサゴナルアーキテクチャにおけるレイヤー
[cols="1,1,1"options="noheader,autowidth",stripes=hover]
|===
^a| *アクター*
a|プライマリアクター

アプリケーション（のアダプタ）を呼び出すもの。ドライバと呼ぶ場合も。

例）

* テストハーネス（＝＞テストハーネスアダプタ）
* ターミナル（＝＞ CUI アダプタ）
* ユーザー（＝＞ GUI アダプタ）
* Web ブラウザ（＝＞ HTTP アダプタ）
* 連携アプリケーション（＝＞ アプリケーションアダプタ）
a|セカンダリアクター

^a| *アダプタ*
a|プライマリアダプタ（ #ユーザーインターフェースレイヤー# ）

アクターの UI とアプリケーションの UI の違いを調整するもの。

例）

* ユーザ向け : アプリケーション本来の利用目的のユースケース向け
** テストハーネスアダプタ : アプリケーション部分のテストのための I/F 。
大量のテストパターン（テスト要因となるパラメタ群と期待する結果）を入力するためにテキストファイルを使えるようにするなど。
できるだけ軽い実装が理想。
** ユーザコマンド : ターミナルからの実行
** GUI : GUI 上からの実行
** HTTP アダプタ : Web ブラウザからの実行や REST API を使った実行 
** アプリケーションアダプタ : 外部アプリケーション連携として呼び出されて実行
** MVC の Controller 役 : 上記の各アダプタも含めた役割的な話
* 管理者向け : アプリケーションを管理するためのユースケース向け
** 管理コマンド
** ログ管理？


a|セカンダリアダプタ（ #インフラストラクチャレイヤー# ）

アプリケーションからの出力方法を調整するもの。

例）

* データ永続化向け
** モックデータベース : 主にテストで使われるもの。出力内容が正しいかどうかの確認に利用
* 外部システム連携向け


^a| *アプリケーション* （ #アプリケーションレイヤー# 、#ドメインレイヤー# ）
2+a| 
* *プライマリポート*
* *セカンダリポート*
* その他
|===

なお、オニオンアーキテクチャやクリーンアーキテクチャではアプリケーション部分がさらにレイヤー分け／詳細化されているため、
実装のイメージがしやすい。

他のアーキテクチャから／への置き換えや実装のしやすさを考慮して、ここではアプリケーションレイヤーとドメインレイヤーを分けて以下に読み換える。

.ヘキサゴナルアーキテクチャにおけるレイヤー（独自）
[cols="1,1,1"options="noheader,autowidth",stripes=hover]
|===
^a| *アクター*
|プライマリアクター
|セカンダリアクター

^a| *アダプタ*
a|
プライマリアダプタ

* #ユーザーインターフェースレイヤー#
* プライマリポートの呼び出し

a|
セカンダリアダプタ

* #インフラストラクチャレイヤー#
* セカンダリポートの実装

.2+^a| *アプリケーション*

2+^a| #アプリケーションレイヤー#
[cols="1,1"]
!===
a!プライマリポート

* ユースケースに合わせたサービスの実装
* ユースケースに合わせたドメインレイヤーのセカンダリポートの呼び出し

a!
セカンダリポート


!===

2+^a| #ドメインレイヤー#
[cols="1,1"]
!===
a!プライマリポート

* サービスのインターフェース

a!セカンダリポート

* リポジトリのインターフェース

2+^!ドメインオブジェクト（値オブジェクト、エンティティ）
!===
|===

ドメインのライフサイクル（集約、ファクトリ、リポジトリ）はどう表現？


ポートはドメインレイヤーで概念としてプログラミング言語でいうところのインターフェース機能などを使って枠だけ用意
サービスはアプリケーションレイヤーでユースケースに合わせて実装、アダプタレイヤー（ユーザーインターフェースレイヤー）でユースケースに合った実装を利用
リポジトリはアダプタレイヤー（インフラストラクチャ層）で実装、アプリケーションレイヤーでユースケースに合った実装を利用

参考として、オニオンアーキテクチャとクリーンアーキテクチャの場合は以下のようになる。

オニオンアーキテクチャ
アプリケーションサービスレイヤーにプライマリポートのインターフェース
ドメインサービスレイヤーにセカンダリポートのインターフェース

クリーンアーキテクチャ
エンティティ（ DDD のエンティティとは別物？）だけがドメインレイヤー。ポートのインターフェースはユースケースレイヤー




入力側や出力側という表現だけではイメージしやすいかもしれないが、
入力へのレスポンスや出力されたデータの参照などが分かりにくくなるため、
公式の例のようにユーザサイドやデータサイド、オニオンアーキテクチャなどの U/I やインフラストラクチャなどの表現の方が良さそう
クリーンアーキテクチャだとコントローラーが入力とプレゼンテーターが出力となってデバイスを通してインフラストラクチャにアクセス
しそうに見える

アダプタについてはプライマリ側をエントリーポイント、セカンダリ側をアダプタと呼んでる例もあり

参考 : https://docs.aws.amazon.com/ja_jp/prescriptive-guidance/latest/hexagonal-architectures/best-practices.html[AWS Prescriptive Guidance, Building hexagonal architectures on AWS, Best practices]

ポート アプリケーション境界の内外のやり取りに利用
ユースケース アプリケーション境界上の内側に存在
ユースケースをポート（アプリケーション境界そのもの）の一部とするか、ポートとは区切られた内側の層とするか？
＝＞ クリーンアーキテクチャだと、境界線そのものがユースケース層であり、入力／出力ポートとインターアクターが存在する。
よって、ポートの一部と見るのが自然っぽい。ただし、外側とやり取りするのは入出力ポートの役割

